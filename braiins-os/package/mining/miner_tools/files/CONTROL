# Copyright (C) 2019  Braiins Systems s.r.o.
#
# This file is part of Braiins Open-Source Initiative (BOSI).
#
# BOSI is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# Please, keep in mind that we may also license BOSI or any part thereof
# under a proprietary license. For more information on the terms and conditions
# of such proprietary license or if you have any other questions, please
# contact us at opensource@braiins.com.

. /lib/zynq.sh
. /lib/functions/bos-defaults.sh
. /usr/share/libubox/jshn.sh
. nand_install.cfg

flash_eraseall() {
	mtd erase "$1"
}

file_size() {
	printf "0x%x" $(stat -c "%s" "$1")
}

get_miner_cfg() {
	bos get_factory_cfg "$1" 2>/dev/null
	return 0
}

use_factory_cfg() {
	test "$USE_FACTORY_CFG" == "yes"
}

SPL_OFF=0x0
UBOOT_OFF=0x0
UBOOT_ENV1_OFF=0x0
UBOOT_ENV2_OFF=0x20000

SRC_BITSTREAM_OFF=0x0
DST_BITSTREAM_OFF=0x300000

SPL_MTD=0
UBOOT_MTD=1
BITSTREAM_MTD=2
UBOOT_ENV_MTD=4

if [ $BOS_MODE == 'nand' ]; then
	# determine current firmware when NAND is mounted
	FIRMWARE_FLAG=$(fw_printenv -n firmware) # 1|2
fi

if [ x${FIRMWARE_FLAG} == x"1" ]; then
	DST_KERNEL_OFF=0x7D00000
	DST_STAGE2_OFF=0x8700000
	DST_STAGE3_OFF=0x9B00000
	SRC_STAGES_MTD=8
else
	DST_KERNEL_OFF=0x1E00000
	DST_STAGE2_OFF=0x2800000
	DST_STAGE3_OFF=0x3C00000
	SRC_STAGES_MTD=7
fi

SRC_KERNEL_OFF=0x0000000
SRC_STAGE2_OFF=0x0A00000
SRC_STAGE3_OFF=0x1E00000
SRC_KERNEL_MTD=$SRC_STAGES_MTD
SRC_STAGE2_MTD=$SRC_STAGES_MTD
SRC_STAGE3_MTD=$SRC_STAGES_MTD

echo "Restoring configuration from NAND..."

# get target specific configuration
. CONFIG

STAGE3_DIR="upgrade"
STAGE3_TMP="stage3"
STAGE3_DST="$STAGE3_TMP/$STAGE3_DIR"
STAGE3_SCRIPT="stage3.sh"

BOSMINER_CFG="bosminer.toml"
BOSMINER_CFG_PATH="/etc/$BOSMINER_CFG"

has_substr() {
	case "$2" in
		*"$1"*) true;;
		*) false;;
	esac
}

# find first slushpool URL and return its userinfo (user.workername)
get_pool_user() {
	local group groups pool pools
	local url user

	if json_is_a group array; then
		json_get_keys groups "group"
		json_select group

		for group in $groups; do
			json_select "$group"
				if json_is_a pool array; then
					json_get_keys pools "pool"
					json_select pool

					for pool in $pools; do
						json_select "$pool"
							json_get_var url "url"
							json_get_var user "user"

							if has_substr "slushpool" "$url" && \
							   has_substr "." "$user"; then
								echo "$user"
								return 0
							fi
						json_select ..
					done

					json_select ..
				fi
			json_select ..
		done

		json_select ..
	fi
	return 0
}

# target specific configuration failed
# try to recover configuration from 'miner_cfg' partition
if use_factory_cfg; then
	if [ -z "$ETHADDR" ]; then
		# get MAC from NAND or running system
		ETHADDR=$(get_miner_cfg "ethaddr")
		[ -n "$ETHADDR" ] || ETHADDR=$(cat /sys/class/net/eth0/address)
	fi

	if [ "$CONFIG_RESULT" != "success" ]; then
		NET_HOSTNAME=$(get_miner_cfg "net_hostname")
		NET_IP=$(get_miner_cfg "net_ip")
		NET_MASK=$(get_miner_cfg "net_mask")
		NET_GATEWAY=$(get_miner_cfg "net_gateway")
		NET_DNS_SERVERS=$(get_miner_cfg "net_dns_servers")
	fi
else
	ETHADDR=$(cat /sys/class/net/eth0/address)

	NET_HOSTNAME=$(uci -q get system.@system[0].hostname || true)
	if [ "$(uci -q get network.lan.proto || true)" == "static" ]; then
		NET_IP=$(uci -q get network.lan.ipaddr || true)
		NET_MASK=$(uci -q get network.lan.netmask || true)
		NET_GATEWAY=$(uci -q get network.lan.gateway || true)
		NET_DNS_SERVERS=$(uci -q get network.lan.dns | tr " " ,)
	fi

	# try to get BOSminer settings
	json_init
	json_load "$(bosminer config --data)"

	json_select status
		json_get_var status_code "code"
	json_select ..
	if [ "$status_code" == "0" ]; then
		json_select data
		if json_is_a autotuning object; then
			json_select autotuning
				if json_is_a psu_power_limit int; then
					json_get_var MINER_PSU_POWER_LIMIT "psu_power_limit"
				fi
			json_select ..
		fi
		MINER_POOL_USER=$(get_pool_user)
		json_select ..
	fi

	# create stage3 tarball to preserve BOSminer configuration
	if [ -f "$BOSMINER_CFG_PATH" ]; then
		mkdir -p "$STAGE3_DST"
		cp "$BOSMINER_CFG_PATH" "$STAGE3_DST"
		cat > "$STAGE3_DST/$STAGE3_SCRIPT" <<-END
			/bin/sh

			cp -f "$BOSMINER_CFG" "$BOSMINER_CFG_PATH"
		END
		tar czf "$STAGE3_FIRMWARE" "$STAGE3_DIR" -C "$STAGE3_TMP"
		rm -rf "$STAGE3_DST"
	fi
fi

AUTO_UPGRADE=yes
[ $(get_miner_cfg "bos_auto_upgrade_enable") == '0' ] && AUTO_UPGRADE=no

if [ -z "$MINER_PSU_POWER_LIMIT" ]; then
	# try to get PSU power limit from NAND or use 'default' value when it is missing
	MINER_PSU_POWER_LIMIT=$(get_miner_cfg "miner_psu_power_limit")
	MINER_PSU_POWER_LIMIT=${MINER_PSU_POWER_LIMIT:-default}
fi

[ -z "$MINER_POOL_USER" ] && MINER_POOL_USER=$(get_miner_cfg "miner_pool_user")

if [ "$CONFIG_RESULT" != "success" ]; then
	MINER_FREQ=$(get_miner_cfg "miner_freq")
	MINER_VOLTAGE=$(get_miner_cfg "miner_voltage")
	MINER_FIXED_FREQ=$(get_miner_cfg "miner_fixed_freq")
fi

if [ -z "$NET_HOSTNAME" ]; then
	KEEP_HOSTNAME="no"
elif [ x"$KEEP_HOSTNAME" == x"cond" ]; then
	KEEP_HOSTNAME="yes"
fi
